part 1:
when the program starts:
1 - it takes the user input as command line arguments (av) 
    and with an if statement it checks if there are 
    no command-line arguments provided or if the first argument is an empty string. 
    If either condition is true, the program returns 0

2 - if not (else),If there are command-line arguments provided, 
    the initialize_stack function is called to initialize stack A. 
    The ac - 2 argument adjusts the number of arguments 
    passed to the function by subtracting 2 to exclude
    the program name and the -c option if present.
    The av + 1 argument passes a pointer to the second element of the av array, skipping the program name. 

3 - initialize_stack: This is the main function responsible for initializing the stack a.
    It takes three arguments: a (a pointer to the stack), ac (the number of command-line arguments),
    and av (an array of command-line arguments).
    It starts by looping through each command-line argument (av) 
    from the end to the beginning, excluding the program name itself.
    For each command-line argument, it splits the string into individual numbers using ft_split function.
    It then iterates through the resulting array of strings (splited
    ) and converts each string into an integer using ft_atol function,
    checking for errors like non-numeric characters and duplicates.
    Finally, it pushes each integer onto the stack a using the push function.
4 - the push takes two parameters a pointer to a pointer to a stack and an integer
    in which we hold the value or the element, we call new_node function that allocates
    a space in memory for the node and set the integer passed in push function as a value 
    of the stack, and set their next and prev value to null.
    after that as long as our prev node is existed (a or b) an its pointers are existed
    (next an prev) we set the actual node next position to the new node we are creating
    and we set the new node prev pointer to the actual node

part 2 :
after we initialize the stack we check if the elements of the stack are sorted or not:
1 - stack_sorted fucntion that is defined as follows int stack_sorted(t_stack *s, int (*sorted)(int, int))
    takes as parameters a pointer to the stack and a pointer to a function (sorted : int sorted(int a, int b))
    The stack_sorted function iterates through each element of the stack s starting 
    from the top (tmp) and moving towards the bottom.
    For each pair of adjacent elements, it calls the sorted function with the values of the 
    current element tmp->value and its previous element tmp->prev->value.
    If the sorted function returns 0 for any pair (indicating that the elements are not in ascending order), 
    the function immediately returns 0, indicating that the stack is not sorted.
    If the loop completes without encountering any unordered pairs, the function returns 1, indicating that the stack is sorted.

2 - if the element are sorted the stack get deallocated by free_stack fucntion
    that take pointer to a pointer to a stack as argument to manupilate the the elements in each new_node
    (freeing them).

part 3:
if the elements of the stack are not sorted then we try to sort them:
1 - we call the start_sort function that takes pointer to a pointer to stack (a and b).
    the function checks how many elements are within our stack that has been pushed earlier in initialize_stack function
    with the help of stack_size function that takes pointer to stack and keep calling itself recursively 
    by taking the previous node as parameter and adding one on each call.  

2 - if the stack size is equal to 2 , we simply run the instruction swap_a in which we swap the top element
    in the stack with the previous element in the stack. (if 2 1 then 1 2).

3 - if the stack size is equal to 3, we call the sort_three function that takes a pointer to a pointer
    to a node, and in this case we consider 5 known scenarios:
    Scenario 1: If the top element is greater than the second element and the second element is less than the third element, 
    the elements are already in ascending order. No sorting operation is required. (if 2 1 3 then 1 2 3)
    Scenario 2: If the top element is greater than the second element but the second element is greater than the third element,
    a swap operation (swap_a) is performed to bring the second smallest element to the top 
    and then a reverse rotate operation to bring the smallest to the top. (if 3 2 1 then 2 3 1 and then 1 2 3)
    Scenario 3: If the top element is greater than the second element and the third element is greater than the second element, 
    a rotation operation (rotate_a) is performed to bring the smallest element to the top. (if 3 1 2 then 1 2 3)
    Scenario 4:  if the top element is less than the second element and the second element is greater than the third element
    a swap operation (swap_a) is performed to bring the second smallest element to the top, followed by 
    a rotation operation (rotate_a) to bring the smallest element to the top.(if 1 3 2 then 3 1 2 and then 1 2 3)
    Scenario 5: If the top element is less than the second element and the third element is greater than the top element, 
    a reverse rotation operation is performed to bring the smallest element to the top.




























test case :
➜  push_swap git:(main) ✗ ./push_swap 8 3 4 9 6 5 0 1 7 33 12 -5 66 -9
ra
ra
ra
ra
ra
ra
pb
pb
ra
ra
ra
pb
rb
ra
pb
rb
ra
pb
rb
pb
rb
ra
pb
pb
rb
pb
rb
pb
pb
sb
pb
pb
rb
pb
rb
pa
pa
pa
rrb
pa
rrb
pa
rrb
pa
pa
rrb
pa
rrb
pa
rrb
pa
pa
pa
pa
pa
➜  push_swap git:(main) ✗ ./push_swap 8 3 4 9 6 5 0 1 7 33 12 -5 66 -9 | wc -l
      55